import type { Area } from 'react-easy-crop'

/**
 * Создает изображение из URL
 */
export const createImage = (url: string): Promise<HTMLImageElement> =>
	new Promise((resolve, reject) => {
		const image = new Image()
		image.addEventListener('load', () => resolve(image))
		image.addEventListener('error', (error) => reject(error))
		image.setAttribute('crossOrigin', 'anonymous')
		image.src = url
	})

/**
 * Получает повернутое изображение
 */
export function getRotatedImage(imageSrc: string, rotation = 0): Promise<string> {
	return new Promise((resolve) => {
		const canvas = document.createElement('canvas')
		const ctx = canvas.getContext('2d')

		if (!ctx) {
			resolve(imageSrc)
			return
		}

		const image = new Image()
		image.src = imageSrc

		image.onload = () => {
			const { width, height } = image

			canvas.width = width
			canvas.height = height

			ctx.translate(width / 2, height / 2)
			ctx.rotate((rotation * Math.PI) / 180)
			ctx.drawImage(image, -width / 2, -height / 2)

			canvas.toBlob((blob) => {
				if (blob) {
					resolve(URL.createObjectURL(blob))
				} else {
					resolve(imageSrc)
				}
			}, 'image/jpeg')
		}
	})
}

/**
 * Обрезает изображение по заданной области
 */
export async function getCroppedImg(imageSrc: string, pixelCrop: Area, rotation = 0): Promise<Blob | null> {
	const image = await createImage(imageSrc)
	const canvas = document.createElement('canvas')
	const ctx = canvas.getContext('2d')

	if (!ctx) {
		return null
	}

	const maxSize = Math.max(image.width, image.height)
	const safeArea = 2 * ((maxSize / 2) * Math.sqrt(2))

	canvas.width = safeArea
	canvas.height = safeArea

	ctx.translate(safeArea / 2, safeArea / 2)
	ctx.rotate((rotation * Math.PI) / 180)
	ctx.translate(-safeArea / 2, -safeArea / 2)

	ctx.drawImage(image, safeArea / 2 - image.width * 0.5, safeArea / 2 - image.height * 0.5)

	const data = ctx.getImageData(0, 0, safeArea, safeArea)

	canvas.width = pixelCrop.width
	canvas.height = pixelCrop.height

	ctx.putImageData(
		data,
		Math.round(0 - safeArea / 2 + image.width * 0.5 - pixelCrop.x),
		Math.round(0 - safeArea / 2 + image.height * 0.5 - pixelCrop.y)
	)

	return new Promise((resolve) => {
		canvas.toBlob((blob) => {
			resolve(blob)
		}, 'image/jpeg')
	})
}
